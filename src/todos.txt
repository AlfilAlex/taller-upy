
=== ./controllers/CreateLotFn.js ===
import { DynamoClient } from '../utils/dynamoClient.js'
import { Presigner } from '../utils/presigner.js';

const client = new DynamoClient();
const presigner = new Presigner();
export const CreateLotFn = (lot) => {

    client.putItem(lot.lotInfo);
    return {
        statusCode: 201,
        body: JSON.stringify(lot.lotInfo)
    }
}

export const GeneratePresignedUrlFn = async (imagesInfoArray) => {
    const presignedUrls = await Promise.all(imagesInfoArray.map(async (imagesInfo) => {
        const { mimeType, fileSize, sha256, userId } = imagesInfo;
        const presignedUrl = await presigner.presign(mimeType, fileSize, sha256, userId);
        return presignedUrl;
    }));
    return {
        statusCode: 200,
        body: JSON.stringify(presignedUrls)
    }
}
=== ./controllers/ListLotsFn.js ===
import { DynamoClient } from '../utils/dynamoClient.js'
export const ListLotsFn = (searchParams) => {
    const client = new DynamoClient();
    try {
        const items = client.getItem(searchParams);
        return {
            statusCode: 200,
            body: JSON.stringify(items)
        };
    } catch (error) {
        console.error("Error listing lots:", error);
        return {
            statusCode: 500,
            body: "Internal Server Error"
        };
    }

}
=== ./controllers/ReserveLotFn.js ===
import { LotModel } from "../utils/dynamoModel.js";

export const ReserveLotFn = async (lotId, userId) => {
    try {
        // Aquí se implementaría la lógica para reservar el lote
        const result = await LotModel.update({
            where: { id: lotId },
            data: { reserved: true, userId: userId }
        });
        return result;
    } catch (error) {
        console.error("Error reserving lot:", error);
        throw new Error("Could not reserve lot");
    }
}

=== ./handlers/CreteLotHandlers.js ===
import { CreateLotFn, GeneratePresignedUrlFn } from '../controllers/CreateLotFn.js';

export const GeneratePresignedUrlFnHandler = async (event) => {
    if (!event || !event.body) {
        return {
            statusCode: 400,
            body: "Invalid request format"
        };
    }
    try {
        const imagesInfoArray = JSON.parse(event.body);
        const response = await GeneratePresignedUrlFn(imagesInfoArray);
        return {
            statusCode: response.statusCode,
            body: response.body
        };
    } catch (error) {
        console.error("Error generating presigned URLs:", error);
        return {
            statusCode: 500,
            body: "Internal Server Error"
        };
    }
}

export const createLotHandler = async (event) => {
    if (!event || !event.body) {
        return {
            statusCode: 400,
            body: "Invalid request format"
        };
    }
    try {
        const lot = JSON.parse(event.body);
        if (!lot || !lot.lotInfo || !lot.lotInfo.userId) {
            return {
                statusCode: 400,
                body: "Invalid lot information"
            };
        }
        const response = CreateLotFn(lot);
        return {
            statusCode: response.statusCode,
            body: response.body
        };
    } catch (error) {
        console.error("Error creating lot:", error);
        return {
            statusCode: 500,
            body: "Internal Server Error"
        };
    }
}
=== ./handlers/ListLotsHandler.js ===
import { ListLotsFn } from '../controllers/ListLotsFn.js';

export const ListLotHandler = async (event) => {
    const searchParams = event.queryStringParameters || {};
    try {
        const items = await ListLotsFn(searchParams);
        return {
            statusCode: items.statusCode,
            body: items.body
        };
    } catch (error) {
        console.error("Error in ListLotHandler:", error);
        return {
            statusCode: 500,
            body: "Internal Server Error"
        };
    }
}
=== ./handlers/ReserveLotsHandler.js ===
import { ReserveLotFn } from '../controllers/ReserveLotFn.js';

export const reserveLotsHandler = async (event, context) => {
    const { lotId, userId } = JSON.parse(event.body);

    try {
        const result = await ReserveLotFn(lotId, userId);

        return {
            statusCode: 200,
            body: JSON.stringify(result)
        };
    } catch (error) {
        console.error("Error reserving lots:", error);
        return {
            statusCode: 500,
            body: "Internal Server Error"
        };
    }
}

=== ./todos.txt ===

=== ./utils/dynamoClient.js ===
import { LotModel } from "./dynamoModel";



export class DynamoClient {
    constructor() {
        this.lotModel = LotModel;
    }

    async putItem(item) {
        try {
            const result = await this.lotModel.create(item);
            return result;
        } catch (error) {
            console.error("Error putting item:", error);
            throw error;
        }
    }

    async getItemById(itemId) {
        try {
            const result = await this.lotModel.get(itemId);
            if (!result) {
                throw new Error(`Item with ID ${itemId} not found`);
            }
            return result;
        } catch (error) {
            console.error("Error getting item:", error);
            throw error;
        }
    }

    async updateItem(item) {
        try {
            const result = await this.lotModel.update(item);
            return result;
        } catch (error) {
            console.error("Error updating item:", error);
            throw error;
        }
    }

    async deleteItem(item) {
        try {
            const result = await this.lotModel.delete(item);
            return result;
        } catch (error) {
            console.error("Error deleting item:", error);
            throw error;
        }
    }
}

=== ./utils/dynamoModel.js ===
// models/lot.model.js
import * as dynamoose from "dynamoose";         //  ❱❱  si usas CommonJS: const dynamoose = require("dynamoose");

const MATERIALS = ["madera", "metal", "vidrio", "textil", "plastico"];
const SCHEMES = ["donacion", "venta"];
const STATUSES = ["OPEN", "LOCKED", "PAID", "DELIVERED"];
const CONDITIONS = ["A", "B", "C"];

/**
 * Esquema Dynamoose
 */
const LotSchema = new dynamoose.Schema(
    {
        pk: { type: String, hashKey: true },           // ej. "lot#<uuid>"
        sk: { type: String, rangeKey: true, default: "meta" },

        material: {
            type: String,
            enum: MATERIALS,                                    // ⬅ validación
            required: true
        },
        condition: {
            type: String,
            enum: CONDITIONS,
            default: "B"
        },
        weightKg: {
            type: Number,
            validate: (v) => v > 0 && v <= 1000                // 1 kg – 1 t
        },

        scheme: { type: String, enum: SCHEMES, required: true },
        price: {
            type: Number,
            validate: (v) => v === 0 || v >= 1                 // 0 = donación
        },
        status: { type: String, enum: STATUSES, default: "OPEN" },
        lockUntil: { type: Date },

        ownerId: { type: String, required: true },          // Generador
        receiverId: { type: String },                          // Receptor (post-reserva)

        address: {
            type: Object,
            schema: {
                line1: { type: String, required: true },
                city: { type: String, default: "Mérida" },
                lat: { type: Number },
                lng: { type: Number }
            }
        },

        images: {
            type: Array,
            schema: [String],
            required: true,
            validate: (arr) => Array.isArray(arr) && arr.length >= 2
        },

        createdAt: { type: Date, default: () => new Date() },
        createdDay: { type: String, default: () => new Date().toISOString().split("T")[0].replace(/-/g, "") },
        updatedAt: { type: Date, default: () => new Date() },
        expiresAt: { type: Number, ttl: true }               // epoch segs – TTL DynamoDB
    },
    {
        timestamps: { createdAt: "createdAt", updatedAt: "updatedAt" },
        saveUnknown: false
    }
);

/* ---------- Índices globales ---------- */

// GSI1: material + status  ➜  para marketplace filtrado
LotSchema.index({
    name: "GSI1_MaterialStatus",
    global: true,
    hashKey: "material",
    rangeKey: "status",
    project: true          // proyecta todos los atributos
});

// GSI2: ownerId + createdAt  ➜  "Mis publicaciones"
LotSchema.index({
    name: "GSI2_OwnerCreated",
    global: true,
    hashKey: "ownerId",
    rangeKey: "createdAt",
    project: ["material", "status", "price", "scheme"]   // proyección reducida
});

// GSI3: receiverId + status  ➜  "Mis reservas"
LotSchema.index({
    name: "GSI3_ReceiverStatus",
    global: true,
    hashKey: "receiverId",
    rangeKey: "status",
    project: ["material", "status", "price", "scheme"]   // proyección reducida
});

// Al insertar, agrega un atributo extra con el día (bucket) yyyyMMdd
LotSchema.index({
    name: "GSI5_CreatedDay",
    global: true,
    hashKey: "createdDay",   // distribuye carga por día
    rangeKey: "createdAt",   // orden cronológico dentro del día
    project: true
});



/* ---------- Modelo ---------- */
export const LotModel = dynamoose.model("Lots", LotSchema, {
    throughput: "ON_DEMAND"   // PAY_PER_REQUEST
});

=== ./utils/presigner.js ===
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

export class Presigner {
    async presign(mimeType, fileSize, sha256, userId) {

        if (fileSize > 10 * 1024 * 1024)
            return { statusCode: 400, body: "Objeto demasiado grande" };

        if (!mimeType || !mimeType.startsWith("image/"))
            return { statusCode: 400, body: "Tipo de archivo no permitido" };

        const key = `uploads/${userId}/${uuid()}`;
        const s3Client = new S3Client({ region: "us-east-1" });
        const command = new PutObjectCommand({
            Bucket: process.env.BUCKET,
            Key: key,
            ContentType: mimeType,
            ContentLength: fileSize,
            ChecksumSHA256: sha256,
            BucketKeyEnabled: true
        });
        ;

        const presigned = await getSignedUrl(s3Client, command, {
            expiresIn: 300,
            signableHeaders: new Set(["content-type"]),
            unhoistableHeaders: new Set([
                "x-amz-checksum-sha256",
            ])
        });

        return { presignedUrl: presigned }

    }
}